# Laste ned nettsider

For 친 minne oss selv p친 hva oppgaven var gjengir vi den her:

::: {.column-margin}
Vi er n친 ferdig med oppvarmingen og kan legge fra oss `hello.py` 游땩
:::

> Vi tar sikte p친 친 bygge opp et enkelt kommandolinje-verkt칮y som tar inn p친
> kommandolinjen nettsider og laster ned sidene.

## Den spede begynnelse

Vi starter med en mal for kommandolinje-verkt칮y og legger f칮lgende i `main.py` i
`cli_workshop` prosjektet v친rt.

```python
import typer
from rich.console import Console

app = typer.Typer()
console = Console()


@app.command()
def main() -> None:
    pass


if __name__ == "__main__":
    app()
```

## Ta inn et argument

F칮r vi begynner 친 laste ned nettsider s친 kan det v칝re greit 친 vite hvilke
nettsider vi skal laste ned. La oss starte med 친 ta inn 칠n nettside og utvide
derfra.

::: {.callout-tip}
## Oppgave
I `main.py` ta inn et argument som er en nettside som brukeren 칮nsker 친 laste
ned. Vi starter enkelt og tar inn bare 칠n nettside og tar den inn som `str`.

Skriv deretter ut nettsiden med `console`.
:::

::: {.callout-note collapse="true"}
## L칮sning
```python
@app.command()
def main(webpage: str) -> None:
    console.print(f"{webpage}")
```
:::

## Ta inn en liste med nettsider

Det holder jo egentlig ikke med bare en nettside, vi m친 ta inn flere! La oss
pr칮ve 친 친pne for at bruker kan gi inn flere nettsider p친 kommandolinjen.

::: {.callout-tip}
## Oppgave
I `main.py` ta inn et argument som er en liste med nettsider som brukeren 칮nsker
친 laste ned.

Skriv deretter ut nettsidene med `console`.
:::

::: {.callout-caution collapse="true"}
## Tips
Vi definerer en liste type i Python sitt typesystem med:

```python
min_liste: list[int] = [1, 2, 3]
```
:::

::: {.callout-note collapse="true"}
## L칮sning
```python
@app.command()
def main(webpages: list[str]) -> None:
    for webpage in webpages:
        console.print(f"{webpage}")
```
:::

## Fremgangsindikator

N친 som vi klarer 친 ta inn en liste med argumenter er det p친 tide 친 gj칮re
verkt칮yet litt mer visuelt. La oss legge til en [fremdriftsindikator med
`rich`](https://rich.readthedocs.io/en/stable/progress.html) og jukse litt for 친
faktisk kunne se den.

Vi legger f칮rst til en fremdriftsindikator for alle nettsidene og deretter
venter litt mellom hver gang vi skriver ut slik at vi kan se hva som skjer.

```python
import time

import typer
from rich.console import Console
from rich.progress import Progress

app = typer.Typer()
console = Console()


@app.command()
def main(webpages: list[str]) -> None:
    with Progress(console=console) as progress: # <1>
        task = progress.add_task("Nettsider lastet ned", total=len(webpages)) # <2>
        for webpage in webpages:
            time.sleep(3) # <3>
            console.print(f"Lastet ned: {webpage}")
            progress.advance(task, advance=1) # <4>


if __name__ == "__main__":
    app()
```
1. Vi oppretter en fremdriftsindikator instans.
2. Vi lager en oppgave 친 vise fremdrift for.
3. Juks for 친 se fremdrift 游봊
4. Vi oppdaterer oppgaven for 친 vise fremdrift.

---

::: {.callout-note}
## Oppgave
Legg til en ny oppgave per nettside og lat som at hver nettside tar 20 runder
med `time.sleep(0.1)` for 친 ferdigstille.

```python
for webpage in webpages:
    for _ in range(20):
        time.sleep(0.1)
        # Oppdater fremdrift her
    console.print(f"Lastet ned: {webpage}")
    progress.advance(task, advance=1)
```
:::

::: {.callout-caution}
## Tips
Pr칮v 친 bruk `progress.remove_task` slik at nedlasting per nettside bare vises
midlertidig.
:::

::: {.callout-note collapse="true"}
## L칮sning
```python
@app.command()
def main(webpages: list[str]) -> None:
    with Progress(console=console) as progress:
        task = progress.add_task("Nettsider lastet ned", total=len(webpages))
        for webpage in webpages:
            page_task = progress.add_task(f"Laster ned [italic magenta]{webpage}[/]", total=20)
            for _ in range(20):
                time.sleep(0.1)
                progress.advance(page_task, advance=1)
            progress.remove_task(page_task)
            progress.advance(task, advance=1)
```
:::

## Laste ned nettsider

La oss n친 legge til funksjonaliteten for 친 laste ned nettsiden som vi f친r inn.

Vi bruker `httpx.get` for 친 laste ned og skriver deretter innholdet til en fil
med samme navn som nettsiden.

```python
@app.command()
def main(webpages: list[str]) -> None:
    with Progress(console=console) as progress:
        task = progress.add_task("Nettsider lastet ned", total=len(webpages))
        for webpage in webpages:
            page_response = httpx.get("https://" + webpage) # <1>
            if page_response.status_code != 200: # <2>
                console.print(f"[red] Klarte ikke 친 laste ned [bold]{webpage}[/bold]!")
            else:
                size: int = page_response.headers.get("Content-Length", len(page_response.content)) # <3>
                page_task = progress.add_task(f"Laster ned [italic magenta]{webpage}[/]", total=size)
                with open(webpage, mode="wb") as fil: # <4>
                    for chunk in page_response.iter_bytes(512): # <4>
                        wrote = fil.write(chunk) # <4>
                        progress.advance(page_task, advance=wrote) # <4>
                        time.sleep(0.01) # <5>
                progress.remove_task(page_task)
            progress.advance(task, advance=1)
```
1. Vi kj칮rer en `GET` mot nettsiden, merk at vi her hardkoder `https://` for 친
gj칮re det enkelt for oss selv.
2. Sjekk at bruker faktisk ga oss en nettside vi kunne n친.
3. Pr칮v 친 hente st칮rrelse p친 nettsiden for fremdriftsindikator.
4. 칀pne fil og skriv bolker med data.
5. Litt mer juks for 친 faktisk se indikator 游봊 (pr칮v 친 ta bort for 친 se hva som skjer).

### Last ned til en gitt mappe

Jeg vet ikke med dere, men jeg synes det er kjipt n친r et verkt칮y laster ned
masse data og skitner til en mappe. For 친 utbedre dette s친 burde vi gi bruker et
valg om 친 oppgi en mappe som vi kan skrive til.

::: {.callout-tip}
## Oppgave
Legg til et kommandolinje-valg som er av typen `pathlib.Path` som er valgfritt.
:::

::: {.callout-note collapse="true"}
## L칮sning
```python
import pathlib # <1>
import time

import httpx
import typer
from rich.console import Console
from rich.progress import Progress

app = typer.Typer()
console = Console()


@app.command()
def main(webpages: list[str], folder: pathlib.Path | None = None) -> None: # <2>
    with Progress(console=console) as progress:
        task = progress.add_task("Nettsider lastet ned", total=len(webpages))
        for webpage in webpages:
            page_response = httpx.get("https://" + webpage)
            if page_response.status_code != 200:
                console.print(f"[red] Klarte ikke 친 laste ned [bold]{webpage}[/bold]!")
            else:
                size: int = page_response.headers.get("Content-Length", len(page_response.content))
                page_task = progress.add_task(f"Laster ned [italic magenta]{webpage}[/]", total=size)
                with open(webpage, mode="wb") as fil:
                    for chunk in page_response.iter_bytes(512):
                        wrote = fil.write(chunk)
                        progress.advance(page_task, advance=wrote)
                        time.sleep(0.01)
                progress.remove_task(page_task)
            progress.advance(task, advance=1)


if __name__ == "__main__":
    app()
```
1. Husk `import`.
2. Kommandolinje-valg. N친r vi bruker `|` representerer det enten den ene typen
eller den andre og med `| None` blir det enten det f칮rste eller ingenting.
:::

Vi m친 huske 친 sjekke at bruker faktisk har oppgitt en mappe. Dette er en nydelig
mulighet til 친 bruke
[`raise typer.Abort()`](https://typer.tiangolo.com/tutorial/terminating/#abort).

::: {.column-margin}
`typer.Abort` er en god m친te 친 avslutte kj칮ring og indikere at noe gikk galt.
`typer.Abort` tar seg av 친 avslutte ordentlig, den skriver ut en liten "Aborted"
for oss og gir riktig signal til terminalen eller programmet som kj칮rte
kommandolinje-verkt칮yet v친rt.
:::

::: {.callout-tip}
## Oppgave
F칮r verkt칮yet v친rt gj칮re noe som helst, sjekk om vi har f친tt en mappe 친 laste
ned til og pass p친 (med
[`pathlib.Path.is_dir`](https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir))
at det faktisk er en mappe. Bare fortsett kj칮ring hvis det faktisk er en mappe.
:::

::: {.callout-note collapse="true"}
## L칮sning
```python
@app.command()
def main(webpages: list[str], folder: pathlib.Path | None = None) -> None:
    if folder: # <1>
        if folder.exists() and not folder.is_dir(): # <2>
            console.print(f"[bold red]Kan ikke laste ned til [i]{folder}[/i], det er ikke en mappe!")
            raise typer.Abort()
        elif not folder.exists(): # <3>
            folder.mkdir()
    # Resten er som f칮r
```
1. Sjekk om vi f친r in valget fra bruker.
2. Hvis stien eksisterer og det ikke er en mappe, fortell bruker at de tar feil.
3. Hvis stien ikke eksisterer lager vi den for bruker.
:::

Tilslutt m친 vi bare bruke mappen hvis den er oppgitt.

```python
file_path = webpage if not folder else folder / webpage
with open(file_path, mode="wb") as fil:
```
